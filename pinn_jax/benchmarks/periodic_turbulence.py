# Copyright 2023, The Johns Hopkins University Applied Physics Laboratory LLC
# All rights reserved. # Distributed under the terms of the Apache 2.0 License.

import pickle
import numpy as np

from jax import numpy as jnp
from flax.core.frozen_dict import FrozenDict

from pinn_jax.bcs import FunctionIC
from pinn_jax.geometry import GeometryXTime, TimeDomain, Rectangle
from pinn_jax.derivatives import get_batch_jacobian
from pinn_jax.utils import get_nn_func

from typing import Callable, Tuple


def get_ic_data(solution_loc: str, cfd_config: dict):
    """load in data generated by jax-cfd and extract its values at t=0"""
    with open(solution_loc + 'data.pkl', 'rb') as f:
        ic_data = pickle.load(f)

    # construct the `xyt` array of stacked `(x, y, t)` tuples
    x = np.linspace(cfd_config['x_min'], cfd_config['x_max'], num=cfd_config['n_x'])
    y = np.linspace(cfd_config['y_min'], cfd_config['y_max'], num=cfd_config['n_y'])
    mesh = np.meshgrid(x, y)
    xyt = np.vstack(list(map(np.ravel, mesh))).T
    xyt = jnp.array(np.hstack([xyt, np.zeros((xyt.shape[0], 1))]))  # append 0 column since this is initial condition

    # extract first time point from system trajectory for x- and y- velocity and vorticity
    u_0 = ic_data['u_traj'][0, :, :].reshape((xyt.shape[0], 1))
    v_0 = ic_data['v_traj'][0, :, :].reshape((xyt.shape[0], 1))
    w_0 = ic_data['w_traj'][0, :, :].reshape((xyt.shape[0], 1))

    return xyt, u_0, v_0, w_0


def get_ic_funcs(config: dict, cfd_config: dict) -> Tuple[Callable, Callable, Callable]:
    xyt, u_0, v_0, w_0 = get_ic_data(config['solution_loc'], cfd_config)

    u_ic_func, v_ic_func, w_ic_func = get_nn_func(u_0, xyt), get_nn_func(v_0, xyt), get_nn_func(w_0, xyt)
    return u_ic_func, v_ic_func, w_ic_func


def get_geom(x_min, x_max, y_min, y_max, t_min, t_max) -> GeometryXTime:
    geometry = Rectangle((x_min, y_min), (x_max, y_max))
    time_domain = TimeDomain(t_min, t_max)
    return GeometryXTime(geometry=geometry, timedomain=time_domain)


def get_ics(geom, u_ic_func, v_ic_func, w_ic_func, ic_weights=None, default_weight=1.0):
    if ic_weights is None:
        ic_weights = {}
    ics = {'u_0': FunctionIC(geom, u_ic_func, component=0),
           'v_0': FunctionIC(geom, v_ic_func, component=1),
           'w_0': FunctionIC(geom, w_ic_func, component=2)}
    component_weights = {key: ic_weights.get(key, default_weight) for key in ics.keys()}
    return ics, component_weights


def get_ic_eval_fn(u_hat: Callable) -> Callable:
    """map tuple (x, y, y) to the set of state variables (u, v, w)"""

    batch_jacobian = get_batch_jacobian(u_hat)

    # reference indices for array slicing
    _u, _v = 0, 1
    _x, _y = 0, 1

    def ic_eval_fn(params: FrozenDict, points: jnp.ndarray) -> jnp.ndarray:
        fields = u_hat(params, points)  # n_batch x n_output = (u, v)
        jacobian = batch_jacobian(params, points).squeeze()  # n_batch x n_output x n_input
        w = jacobian[:, _v, _x] - jacobian[:, _u, _y]  # partial_x v - partial_y u

        return jnp.hstack([fields[:, [_u]], fields[:, [_v]], w[:, None]])

    return ic_eval_fn
